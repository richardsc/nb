#!/usr/bin/env python3

'''
There are several ways to use nb.

na add --title "oceanpython" --keyword "lecture,python" --content "It was a great talk"
na add --title "life is grand"     # opens up a text editor to get keywords and content
na add                             # interact with user to get the note information
na add --mode json < notes.json    # infer notes from a JSON file (ignore other arguments)
nb                                 # show all notes
nb find                            #   "   "    "
na find --keyword "lecture"        # show notes with keyword 'lecture'
'''
from nbclass import Nb
import argparse
import sys
import json
import os
import re
import datetime
from time import strptime
import subprocess

def get_from_dotfile(file, token, default=""):
    try:
        with open(os.path.expanduser(file), "r") as f:
            for line in f.readlines():
                line = re.sub(r'#.*', r'', line)
                tokens = line.split("=")
                tokens = line.split("=")
                tokens[0] = tokens[0].strip()
                tokens[1] = tokens[1].strip()
                tokens[1] = tokens[1].strip('"')
                if tokens[0] == token:
                    return(tokens[1])
            return(default)
    except:
        error("cannot open file '%s'" % file, file=sys.stderr)

parser = argparse.ArgumentParser(prog="nb", description="Nota Bene: an organizer for textual notes", epilog="(In active development)")

# 'nb' is an alias for 'nb find'
have_args = len(sys.argv) > 1
if have_args:
    parser.add_argument("action")#, choices=["add", "find", "edit", "delete", "version", "RESET", "cleanup", "developer"])
parser.add_argument('-i', '--id', type=int, help="ID number of note to delete")
parser.add_argument('-m', '--mode', type=str, default="interactive", choices=['interactive', 'plain', 'json', 'markdown'],
        help="method for i/o")
parser.add_argument('-t', "--title", type=str, default="", help="title (short)")
parser.add_argument("-k", "--keywords", type=str, default="", help="comma-separated keywords")
parser.add_argument('-c', "--content", type=str, default="", help="content")
parser.add_argument("--count", action="store_true", dest="count", default=False, help="report only count of found results")
parser.add_argument('-d', "--debug", action="store_true", dest="debug", default=False, help="set debugging on")
parser.add_argument("--privacy", type=int, default=0, help="set privacy level (0=open, 1=closed)")
parser.add_argument("--file", type=str, help="filename for input (add) or output (find)")
defaultDatabase = get_from_dotfile("~/.nbrc", "db", "~/Dropbox/nb.db")
parser.add_argument("--db", type=str, default=defaultDatabase, help="filename for database")
parser.add_argument("--strict", action="store_true", default=False, help="use strict search?")
parser.add_argument("--due", type=str, default="", help="time when item is due [not used yet]")
parser.add_argument('-p', "--pretty", type=str, default="", help="format for note output")
args = parser.parse_args()

args.keywordsoriginal = args.keywords
args.keywords = args.keywords.split(',')

# look in ~/.nbrc to see if a database is named there
if not args.pretty:
    args.pretty = get_from_dotfile("~/.nbrc", "pretty", "all")

nb = Nb(debug=args.debug, db=args.db, quiet=args.count)

if args.file:
    file = args.file
else:
    file = "stdout"

if args.title:
    if args.action != "add":
        nb.warning("--title is ignored unless --action!='add'")
    title = args.title
else:
    title = ""
if args.content:
    if args.action != "add":
        nb.warning("--content is ignored unless --action='add'")
    content = args.content
else:
    content = ""

## This conditional block is very long, and may be hard to read.

## a trick so that e.g. 'nb 1' becomes 'nb find --id 1'
try:
    args.id = int(args.action)
    args.action = "find"
except:
    pass

if have_args and args.action == "add":
    if args.mode == 'json':
        if not args.file:
            nb.error("Must use --file to name an input file")
        for line in open(args.file, "r"):
            line = line.rstrip()
            if args.debug:
                print(line, '\n')
            if (len(line)) > 1:
                try:
                    j = json.loads(line)
                    if args.debug:
                        print(j)
                except:
                    nb.error("JSON file is not in proper format on line: %s" % line)
                if 'title' not in j:
                    sys.exit(1)
                if 'content' not in j:
                    j['content'] = ""
                if 'keywords' in j:
                    keyword = j['keywords'].split(',')
                else:
                    keyword = ''
                if 'privacy' not in j:
                    j['privacy'] = 0
                j['keywords'].split(',')
                id = nb.add(title=j['title'], keywords=keyword, content=j['content'], privacy=j['privacy'])
        sys.exit(0)
    elif args.mode== 'plain' and (args.title == "" and args.content == ""):
        lines = sys.stdin.readlines()
        if nb.debug:
            print('reading from stdin')
        # trim newlines, plus any blank lines at start and end [FIXME: inelegant in the extreme]
        trim = 0
        nlines = len(lines)
        for l in range(nlines):
            if len(lines[l].strip()) < 1:
                trim += 1
            else:
                break
        lines = [lines[i].rstrip('\n') for i in range(trim, nlines)]
        trim = 0
        nlines = len(lines)
        for l in reversed(list(range(nlines))):
            if len(lines[l].strip()) < 1:
                trim += 1
            else:
                break
        lines = [lines[i].rstrip('\n') for i in range(0, nlines-trim)]
        # finally (after all that bad code!) we can parse for content
        title = ""
        content = ""
        keywords = []
        for line in lines:
            if nb.debug:
                print("analysing line \"%s\"" % line)
            if title == "":
                if line == "":
                    next # FIXME: should this be 'continue'?
                title = line.strip()
            elif '<' in line:
                keywords = re.sub(r'<.*>', '', line).strip()
                keywords = re.sub(r' *\] *\[ *', ',', keywords).strip()
                keywords = re.sub(r' *\[ *', '', keywords).strip()
                keywords = re.sub(r' *\] *', '', keywords).strip()
                keywords = keywords.split(',')
            else:
                if content == "" and line == "":
                    next # FIXME: should this be 'continue'?
                content = content.lstrip() + line + '\n'
        if nb.debug:
            print("title:", title)
            print("keywords:", keywords)
            print("content: (%s)" % content)
        id = nb.add(title=title, keywords=keywords, content=content, privacy=args.privacy)
    elif args.mode == 'interactive' and (args.title == "" or args.content == "" or args.keywords == ""):
        if args.debug:
            print("should handle interactive now")
        # append repo name ... FIXME: should be a flag controlling whether to do this
        git_repo = nb.find_git_repo()
        if git_repo:
            if len(args.keywords) > 0 and args.keywords[0] != "":
                args.keywords.insert(0, git_repo.strip())
            else:
                args.keywords = [git_repo]
        ee = nb.editor_entry(title=args.title, keywords=args.keywords, content=args.content, privacy=args.privacy, due=args.due)
        id = nb.add(title=ee["title"], keywords=ee["keywords"], content=ee["content"], privacy=ee["privacy"], due=ee["due"])
    else:
        id = nb.add(title=args.title, keywords=args.keywords, content=args.content, privacy=args.privacy, due=args.due)
elif (not have_args) or args.action == "find":
    due_requested = nb.interpret_time(args.due)
    #print("due_requested:", due_requested)
    if args.keywords[0] != '':
        found = nb.find(keywords=args.keywords, mode=args.mode, strict=args.strict)
    elif args.id:
        found = nb.find(id=args.id, mode=args.mode, strict=args.strict)
    else:
        found = nb.find(keywords='?'.split(','), mode=args.mode, strict=args.strict)
    count = 0
    nfound = len(found)
    for f in found:
        #print(f)
        try:
            due = f['due']
        except:
            due = None
        #print("len(due): %d" % len(due))
        if due_requested[0]:
            if not due:
                continue
            if args.debug:
                print("due_requested: %s" % due_requested[0])
            due = datetime.datetime.strptime(due, '%Y-%m-%d %H:%M:%S.%f')
            if args.debug:
                print("due value stored in note:", due)
            if due > due_requested[0]:
                when = (due - due_requested[0]).total_seconds()
            else:
                when = (due_requested[0]- due).total_seconds()
            if args.debug:
                print('when:', when)
            if when < 0:
                continue
        count += 1
        if args.count:
            continue
        elif args.mode == "json":
            print(f['json'])
        elif args.mode== 'markdown':
            print("**%s**\n" %f ['title'])
            print("<%s>\n" %f ['noteId'], end='')
            for k in f['keywords']:
                print("[%s] " % k, end='')
            print("{%s / %s}\n" % (f['date'], f['modified']))
            print(f['content'].lstrip())
        else:
            if args.pretty == "oneline" and nfound > 1:
                print("<%s> " %f ['noteId'], end="")
                print("[", " ] [ ".join(f['keywords'][i] for i in range(len(f['keywords']))), "]",end='')
                print(" : %s" % f['title'])
            else:
                print("%s" % f['title'])
                print("  ", "[", " ] [ ".join(f['keywords'][i] for i in range(len(f['keywords']))), "]",end='')
                print(" <%s>" % f['noteId'], end='')
                print(" {%s / %s} " % (f['date'], f['modified']), end="")
                #print(" {%s} " % f['date'], end="")
                if f['due'] and len(f['due']) > 0:
                    due = datetime.datetime.strptime(f['due'], '%Y-%m-%d %H:%M:%S.%f') # FIXME: make this 'due' DRY (+-20 lines)
                    #print " (due %s)" % f['due']
                    #print "due:", due
                    now = datetime.datetime.now()
                    #print "now:", now
                    when = abs(due - now).total_seconds()
                    #print "when:", when
                    if due > now:
                        if when < 2 * 3600:
                            print("(due in %d minutes)" % (when / 60))
                        elif when < 86400:
                            print("(due in %d hours)" % (when / 3600))
                        else:
                            print("(due in %d days)" % (when / 3600 / 24))
                    else:
                        if when < 2 * 3600:
                            print("(overdue by %d minutes)" % (when / 60))
                        elif when < 86400:
                            print("(overdue by %d hours)" % (when / 3600))
                        else:
                            print("(overdue by %.1f days)" % (when / 3600 / 24))
                else:
                    print('')
                content = f['content'].replace('\\n', '\n')
                if not args.pretty == "twoline":
                    for contentLine in content.split('\n'):
                        c = contentLine.rstrip('\n')
                        if len(c):
                            print("  ", contentLine.rstrip('\n'))
                    print('')
    if args.count:
        print(count)
elif args.action == "delete":
    if not args.id:
        nb.error("must give a note ID number (shown in <> by 'nb find')")
        sys.exit(1)
    if args.debug:
        print("note with id number", args.id, "should be deleted now")
    nb.delete(args.id)
elif args.action == "edit":
    if args.id:
        idnew = nb.edit(args.id)
        if args.debug:
            print("new note is numbered %d" % idnew)
    elif args.keywords:
        if args.debug:
            print("KEYWORD \"%s\"" % args.keywordsoriginal)
        try:
            k = args.keywordsoriginal.split('=')
        except:
            nb.error("must specify e.g. 'nb edit --keyword OLD=NEW'")
        nb.rename_keyword(k[0], k[1])
    else:
        nb.error("must give a note ID number (shown in <> by 'nb find') or a keyword")
elif args.action == "RESET":
    nb.initialize(author="me")
elif args.action == "cleanup":
    nb.cleanup()
elif args.action == "version":
    print(nb.version())
elif args.action == "developer":
    repo = nb.find_git_repo()
    if repo:
        print("DEVELOPER: in a git repo named: '%s'; maybe we should auto-tag with this?" % repo)

