#!/usr/bin/python

'''
There are several ways to use nb.

./na add --title "oceanpython lecture" --keyword "lecture,python" --content "Diego gave a great talk"
./na add                             # interact with user to get the note information
./na add --mode json < notes.json    # infer notes from a JSON file (ignore any other arguments)
./na find                            # show all notes
./na find --keyword "lecture"        # show notes with keyword 'lecture'
'''

from nbclass import Nb
import argparse
import sys
import json
import os
import re
import datetime
from time import strptime

# look in ~/.nbrc to see if a database is named there
defaultDatabase = "~/Dropbox/nb.db"
try:
    with open(os.path.expanduser("~/.nbrc"), "r") as f:
        tokens = f.readline().split("=")
        tokens[0] = tokens[0].strip()
        tokens[1] = tokens[1].strip()
        tokens[1] = tokens[1].strip('"')
        if tokens[0] == "db":
            defaultDatabase = tokens[1] # over-ride
except:
    pass

parser = argparse.ArgumentParser()
parser.add_argument('action', choices=['add', 'find', 'delete', 'version', 'RESET', 'cleanup'])
parser.add_argument('-i', '--id', type=int, help="ID number of note to delete")
parser.add_argument('-m', '--mode', type=str, default="interactive", choices=['interactive', 'plain', 'json'],
        help="method for i/o")
parser.add_argument('-t', "--title", type=str, default="", help="title (short)")
parser.add_argument("-k", "--keywords", type=str, default="", help="comma-separated keywords")
parser.add_argument('-c', "--content", type=str, default="", help="content")
parser.add_argument('-d', "--debug", action="store_true", dest="debug", default=False, help="set debugging on")
parser.add_argument('-p', "--privacy", type=int, default=0, help="set privacy level (0=open, 1=closed)")
parser.add_argument("--file", type=str, help="filename for input (add) or output (find)")
parser.add_argument("--db", type=str, default=defaultDatabase, help="filename for database")
parser.add_argument("--strict", action="store_true", default=False, help="use strict search?")
parser.add_argument("--due", type=str, default="", help="time when item is due [not used yet]")
args = parser.parse_args()

args.keywords = args.keywords.split(',')

nb = Nb(debug=args.debug, db=args.db)

if args.file:
    file = args.file
else:
    file = "stdout"

if args.title:
    if args.action != "add":
        print "warning: --title is ignored unless --action!='add'"
    title = args.title
else:
    title = ""
if args.content:
    if args.action != "add":
        print "warning: --content is ignored unless --action='add'"
    content = args.content
else:
    content = ""

if args.action == "add":
    if args.mode == 'json':
        if not args.file:
            print "Must use --file to name an input file"
            sys.exit(1)
        for line in open(args.file, "r"):
            line = line.rstrip()
            if args.debug:
                print line, '\n'
            if (len(line)) > 1:
                try:
                    j = json.loads(line)
                    if args.debug:
                        print j
                except:
                    print "JSON file is not in proper format on line: %s" % line
                    sys.exit(1)
                if 'title' not in j:
                    sys.exit(1)
                if 'content' not in j:
                    j['content'] = ""
                if 'keywords' in j:
                    keyword = j['keywords'].split(',')
                else:
                    keyword = ''
                if 'privacy' not in j:
                    j['privacy'] = 0
                j['keywords'].split(',')
                id = nb.add(title=j['title'], keywords=keyword, content=j['content'], privacy=j['privacy'])
        sys.exit(0)
    elif args.mode== 'plain' and (args.title == "" and args.content == ""):
        lines = sys.stdin.readlines()
        if nb.debug:
            print 'reading from stdin'
        # trim newlines, plus any blank lines at start and end [FIXME: inelegant in the extreme]
        trim = 0
        nlines = len(lines)
        for l in range(nlines):
            if len(lines[l].strip()) < 1:
                trim += 1
            else:
                break
        lines = [lines[i].rstrip('\n') for i in range(trim, nlines)]
        trim = 0
        nlines = len(lines)
        for l in reversed(range(nlines)):
            if len(lines[l].strip()) < 1:
                trim += 1
            else:
                break
        lines = [lines[i].rstrip('\n') for i in range(0, nlines-trim)]
        # finally (after all that bad code!) we can parse for content
        title = ""
        content = ""
        keywords = []
        for line in lines:
            if nb.debug:
                print "analysing line \"%s\"" % line
            if title == "":
                if line == "":
                    next # FIXME: should this be 'continue'?
                title = line.strip()
            elif '<' in line:
                keywords = re.sub(r'<.*>', '', line).strip()
                keywords = re.sub(r' *\] *\[ *', ',', keywords).strip()
                keywords = re.sub(r' *\[ *', '', keywords).strip()
                keywords = re.sub(r' *\] *', '', keywords).strip()
                keywords = keywords.split(',')
            else:
                if content == "" and line == "":
                    next # FIXME: should this be 'continue'?
                content = content.lstrip() + line + '\n'
        if nb.debug:
            print "title:", title
            print "keywords:", keywords
            print "content: (%s)" % content 
        id = nb.add(title=title, keywords=keywords, content=content, privacy=args.privacy)
    elif args.mode == 'interactive' and (args.title == "" and args.content == ""):
        print "should handle interactive now"
        keywords = nb.cur.execute("SELECT keywordId, keyword FROM keyword ORDER BY UPPER(keyword);")
        msg = "Keywords (perhaps one of following) " + ",".join(str(kw[1]) for kw in keywords) + ": "
        keywords = raw_input(msg).split(',')
        title = raw_input("Title: ")
        #privacy = raw_input("Privacy (numeric): ")
        #privacy = int(privacy)
        print "Content: ('.' as first charcter of line, to end)"
        content = ""
        while True:
            c = raw_input("> ").rstrip('\n')
            if c and c[0] == '.':
                break
            else:
                content = content + c + '\n'
        content.rstrip('\n')
        id = nb.add(title=title, keywords=keywords, content=content)
    else:
        id = nb.add(title=args.title, keywords=args.keywords, content=args.content, due=args.due, privacy=args.privacy)

if args.action == "find":
    due_requested = nb.interpret_time(args.due)
    #print "due_requested:", due_requested
    if args.keywords[0] != '':
        found = nb.find(keywords=args.keywords, mode=args.mode, strict=args.strict)
    elif args.id:
        found = nb.find(id=args.id, mode=args.mode, strict=args.strict)
    else:
        found = nb.find(keywords='?'.split(','), mode=args.mode, strict=args.strict)
    for f in found:
        due = f['due']
        #print "len(due): %d" % len(due)
        if due_requested[0]:
            if not due:
                continue
            #print "due (%s)" % due_requested[0]
            due = datetime.datetime.strptime(due, '%Y-%m-%d %H:%M:%S.%f')
            #print "due:", due
            if due > due_requested[0]:
                when = (due - due_requested[0]).total_seconds()
            else:
                when = (due_requested[0]- due).total_seconds()
            #print 'when:', when
            if when > due_requested[1]:
                continue
        if args.mode== "json":
            print f['json']
        else:
            #print "%s   <%s>" % (f['title'], f['noteId']),
            print "%s\n   <%s>" % (f['title'], f['noteId']),
            print "[", " ] [ ".join(f['keywords'][i] for i in range(len(f['keywords']))), "]",
            if f['due'] and len(f['due']) > 0:
                due = datetime.datetime.strptime(f['due'], '%Y-%m-%d %H:%M:%S.%f') # FIXME: make this 'due' DRY (+-20 lines)
                #print " (due %s)" % f['due']
                #print "due:", due
                now = datetime.datetime.now()
                #print "now:", now
                when = (due - now).total_seconds()
                #print "when:", when
                if due > now:
                    if when < 2*3600:
                        print "(due in %d minutes)" % (when / 60)
                    elif when < 86400:
                        print "(due in %d hours)" % (when / 3600)
                    else:
                        print "(due in %d days)" % (when / 3600 / 24)
                else:
                    if when < 2*3600:
                        print "(overdue by %d minutes)" % (when / 60)
                    elif when < 86400:
                        print "(overdue by %d hours)" % (when / 3600)
                    else:
                        print "(overdue by %d days)" % (when / 3600 / 24)
            else:
                print ''
            content = f['content'].replace('\\n', '\n')
            for contentLine in content.split('\n'):
                print "  ", contentLine.rstrip('\n')
            print ''

if args.action == "delete":
    if not args.id:
        print "must give a note ID number (in <>) in the 'nb find' view"
        sys.exit(1)
    if args.debug:
        print "note with id number", args.id, "should be deleted now"
    nb.delete(args.id)


if args.action == "RESET":
    nb.initialize(author="me")

if args.action == "cleanup":
    nb.cleanup()

if args.action == "version":
    nb.version()

