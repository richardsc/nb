#!/usr/bin/python

'''
There are several ways to use nb.

na -a                         # open up an editor to make a new note ('-a' is short for '--add')
na -a -t "life is grand"      # as above, but preset note title ('-t' is short for '--title')
na -a -m json < notes.json    # infer notes from a JSON file (ignore other arguments)

nb                            # show all notes
nb 1                          # show note #1
nb 1 -m markdown              # show note #1 in markdown format ('-m' is short for '--mode')
nb -k "lecture"               # show notes with keyword 'lecture' ('-k' is short for '--keyword')

nb 1 -e                       # edit note #1 ('-e' is short for '--edit')

nb 1 -d                       # delete note #1

Note: the note ID must always be in the first argument, preceeding any other arguments.

'''
from __future__ import print_function
from nbclass import Nb
import argparse
import sys
import json
import os
import re
import datetime
from time import strptime
import subprocess

def get_from_dotfile(file, token, default=""):
    try:
        with open(os.path.expanduser(file), "r") as f:
            for line in f.readlines():
                line = re.sub(r'#.*', r'', line)
                tokens = line.split("=")
                tokens = line.split("=")
                tokens[0] = tokens[0].strip()
                tokens[1] = tokens[1].strip()
                tokens[1] = tokens[1].strip('"')
                if tokens[0] == token:
                    return(tokens[1])
            return(default)
    except:
        error("cannot open file '%s'" % file, file=sys.stderr)


# If second arg is a number, it is a noteId
id_desired = None
if len(sys.argv) > 1:
    try:
        id_desired = int(sys.argv[1])
        del sys.argv[1]
    except:
        pass

parser = argparse.ArgumentParser(prog="nb", description="Nota Bene: an organizer for textual notes", epilog="(In active development)")

parser.add_argument('-i', '--id', type=int, help="ID number of note to work with")
parser.add_argument('-a', "--add", action="store_true", dest="add", default=False, help="add a note")
parser.add_argument('-e', "--edit", action="store_true", dest="edit", default=False, help="edit a note")
parser.add_argument('-d', "--delete", action="store_true", dest="delete", default=False, help="delete a note")
parser.add_argument('-m', '--mode', type=str, default="interactive", choices=['interactive', 'plain', 'json', 'markdown'],
        help="method for i/o")
parser.add_argument('-t', "--title", type=str, default="", help="title (short)")
parser.add_argument("-k", "--keywords", type=str, default="", help="comma-separated keywords")
parser.add_argument('-c', "--content", type=str, default="", help="content")
parser.add_argument("--count", action="store_true", dest="count", default=False, help="report only count of found results")
parser.add_argument("--debug", action="store_true", dest="debug", default=False, help="set debugging on")
parser.add_argument("--privacy", type=int, default=0, help="set privacy level (0=open, 1=closed)")
parser.add_argument("--file", type=str, help="filename for input (add) or output (find)")
defaultDatabase = get_from_dotfile("~/.nbrc", "db", "~/Dropbox/nb.db")
parser.add_argument("--db", type=str, default=defaultDatabase, help="filename for database")
parser.add_argument("--strict", action="store_true", default=False, help="use strict search?")
parser.add_argument("--due", type=str, default="", help="time when item is due [not used yet]")
parser.add_argument('-p', "--pretty", type=str, default="", help="format for note output")
parser.add_argument('-v', "--version", action="store_true", dest="version", default=False, help="get version number")
parser.add_argument("--developer", action="store_true", default=False, help="flag for the developer *only*")
args = parser.parse_args()

args.keywordsoriginal = args.keywords
args.keywords = args.keywords.split(',')

if args.version:
    print(nb.version())
    sys.exit(0)

# look in ~/.nbrc to see if a database is named there
if not args.pretty:
    args.pretty = get_from_dotfile("~/.nbrc", "pretty", "all")

nb = Nb(debug=args.debug, db=args.db, quiet=args.count)

if args.file:
    file = args.file
else:
    file = "stdout"

if args.title:
    title = args.title
else:
    title = ""
if args.content:
    content = args.content
else:
    content = ""

if args.add:
    if args.mode == 'json':
        if not args.file:
            nb.error("Must use --file to name an input file")
        for line in open(args.file, "r"):
            line = line.rstrip()
            if args.debug:
                print(line, '\n')
            if (len(line)) > 1:
                try:
                    j = json.loads(line)
                    if args.debug:
                        print(j)
                except:
                    nb.error("JSON file is not in proper format on line: %s" % line)
                if 'title' not in j:
                    sys.exit(1)
                if 'content' not in j:
                    j['content'] = ""
                if 'keywords' in j:
                    keyword = j['keywords'].split(',')
                else:
                    keyword = ''
                if 'privacy' not in j:
                    j['privacy'] = 0
                j['keywords'].split(',')
                id = nb.add(title=j['title'], keywords=keyword, content=j['content'], privacy=j['privacy'])
        sys.exit(0)
    elif args.mode== 'plain' and (args.title == "" and args.content == ""):
        lines = sys.stdin.readlines()
        if nb.debug:
            print('reading from stdin')
        # trim newlines, plus any blank lines at start and end [FIXME: inelegant in the extreme]
        trim = 0
        nlines = len(lines)
        for l in range(nlines):
            if len(lines[l].strip()) < 1:
                trim += 1
            else:
                break
        lines = [lines[i].rstrip('\n') for i in range(trim, nlines)]
        trim = 0
        nlines = len(lines)
        for l in reversed(list(range(nlines))):
            if len(lines[l].strip()) < 1:
                trim += 1
            else:
                break
        lines = [lines[i].rstrip('\n') for i in range(0, nlines-trim)]
        # finally (after all that bad code!) we can parse for content
        title = ""
        content = ""
        keywords = []
        for line in lines:
            if nb.debug:
                print("analysing line \"%s\"" % line)
            if title == "":
                if line == "":
                    next # FIXME: should this be 'continue'?
                title = line.strip()
            elif '<' in line:
                keywords = re.sub(r'<.*>', '', line).strip()
                keywords = re.sub(r' *\] *\[ *', ',', keywords).strip()
                keywords = re.sub(r' *\[ *', '', keywords).strip()
                keywords = re.sub(r' *\] *', '', keywords).strip()
                keywords = keywords.split(',')
            else:
                if content == "" and line == "":
                    next # FIXME: should this be 'continue'?
                content = content.lstrip() + line + '\n'
        if nb.debug:
            print("title:", title)
            print("keywords:", keywords)
            print("content: (%s)" % content)
        id = nb.add(title=title, keywords=keywords, content=content, privacy=args.privacy)
    elif args.mode == 'interactive' and (args.title == "" or args.content == "" or args.keywords == ""):
        if args.debug:
            print("should handle interactive now")
        # append repo name ... FIXME: should be a flag controlling whether to do this
        git_repo = nb.find_git_repo()
        if git_repo:
            if len(args.keywords) > 0 and args.keywords[0] != "":
                args.keywords.insert(0, git_repo.strip())
            else:
                args.keywords = [git_repo]
        ee = nb.editor_entry(title=args.title, keywords=args.keywords, content=args.content, privacy=args.privacy, due=args.due)
        id = nb.add(title=ee["title"], keywords=ee["keywords"], content=ee["content"], privacy=ee["privacy"], due=ee["due"])
    else:
        id = nb.add(title=args.title, keywords=args.keywords, content=args.content, privacy=args.privacy, due=args.due)
    sys.exit(0)

elif args.edit:
    if args.keywords[0] != "":
        if args.debug:
            print("KEYWORD \"%s\"" % args.keywordsoriginal)
        try:
            k = args.keywordsoriginal.split('=')
        except:
            nb.error("must specify e.g. 'nb edit --keyword OLD=NEW'")
        if args.debug:
            nb.fyi("renaming '%s' to '%s'" % (k[0], k[1]))
        nb.rename_keyword(k[0], k[1])
    else:
        if not id_desired:
            nb.error("must provide an ID, e.g. 'nb 1 -e' to edit note with ID=1")
        idnew = nb.edit(id_desired)
    sys.exit(0)


elif args.delete:
    if not id_desired:
        nb.error("must give a note ID number (shown in <> by 'nb find')")
        sys.exit(1)
    if args.debug:
        nb.fyi("note with id number", id_desired, "should be deleted now")
    nb.delete(id_desired)
    sys.exit(0)


elif args.developer:
    repo = nb.find_git_repo()
    if repo:
        print("DEVELOPER: in a git repo named: '%s'; maybe we should auto-tag with this?" % repo)
    sys.exit(0)

else: # By a process of elimination, we must be trying to find notes.
    due_requested = nb.interpret_time(args.due)
    if id_desired:
        found = nb.find(id=id_desired, mode=args.mode, strict=args.strict)
    elif args.keywords[0] != '':
        found = nb.find(keywords=args.keywords, mode=args.mode, strict=args.strict)
    elif args.id:
        found = nb.find(id=args.id, mode=args.mode, strict=args.strict)
    else:
        found = nb.find(keywords='?'.split(','), mode=args.mode, strict=args.strict)
    count = 0
    nfound = len(found)
    for f in found:
        #print(f)
        try:
            due = f['due']
        except:
            due = None
        #print("len(due): %d" % len(due))
        if due_requested[0]:
            if not due:
                continue
            if args.debug:
                print("due_requested: %s" % due_requested[0])
            due = datetime.datetime.strptime(due, '%Y-%m-%d %H:%M:%S.%f')
            if args.debug:
                print("due value stored in note:", due)
            if due > due_requested[0]:
                when = (due - due_requested[0]).total_seconds()
            else:
                when = (due_requested[0]- due).total_seconds()
            if args.debug:
                print('when:', when)
            if when < 0:
                continue
        count += 1
        if args.count:
            continue
        elif args.mode == "json":
            print(f['json'])
        elif args.mode== 'markdown':
            print("**%s**\n" %f ['title'])
            print("<%s> " %f ['noteId'], end='')
            for k in f['keywords']:
                print("[%s] " % k, end='')
            print("{%s / %s}\n" % (f['date'], f['modified']))
            print(f['content'].lstrip())
        else:
            if args.pretty == "oneline" and nfound > 1:
                print("<%s> " %f ['noteId'], end="")
                print("[", " ] [ ".join(f['keywords'][i] for i in range(len(f['keywords']))), "]",end='')
                print(" : %s" % f['title'])
            else:
                print("%s" % f['title'])
                print("  ", "[", " ] [ ".join(f['keywords'][i] for i in range(len(f['keywords']))), "]",end='')
                print(" <%s>" % f['noteId'], end='')
                print(" {%s / %s} " % (f['date'], f['modified']), end="")
                #print(" {%s} " % f['date'], end="")
                if f['due'] and len(f['due']) > 0:
                    due = datetime.datetime.strptime(f['due'], '%Y-%m-%d %H:%M:%S.%f') # FIXME: make this 'due' DRY (+-20 lines)
                    #print " (due %s)" % f['due']
                    #print "due:", due
                    now = datetime.datetime.now()
                    #print("\n")
                    #print ("now:", now)
                    #print ("due:", due)
                    when = abs(due - now).total_seconds()
                    #print ("when:", when)
                    if due > now:
                        if when < 2 * 3600:
                            print("(due in %d minutes)" % round(when / 60))
                        elif when < 86400:
                            print("(due in %d hours)" % round(when / 3600))
                        else:
                            print("(due in %d days)" % round(when / 3600 / 24))
                    else:
                        if when < 2 * 3600:
                            print("(overdue by %d minutes)" % (when / 60))
                        elif when < 86400:
                            print("(overdue by %d hours)" % (when / 3600))
                        else:
                            print("(overdue by %.1f days)" % (when / 3600 / 24))
                else:
                    print('')
                content = f['content'].replace('\\n', '\n')
                if not args.pretty == "twoline":
                    for contentLine in content.split('\n'):
                        c = contentLine.rstrip('\n')
                        if len(c):
                            print("  ", contentLine.rstrip('\n'))
                    print('')
    if args.count:
        print(count)
    

